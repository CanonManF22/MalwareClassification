import math
import numpy as np
import pickle

N = 2   # Number of hidden states in the model
M = 27  # Number of unique observation symbols
observation = pickle.load(open("observation.p", "rb"))['observation_list']  # Observation sequence expressed in ints

T = 50000 #length of observation sequence
maxIters = 1
alphaConstant = 12.5
temperature = 2.5
A = np.random.rand(N,N)
A = np.apply_along_axis(lambda x : abs(x - (np.sum(x) - 1) / len(x)), 1, A)
B = np.random.uniform(1/(M+1), 1/M,(N,M))
B = np.apply_along_axis(lambda x : abs(x - (np.sum(x) - 1) / len(x)), 1, B)   # Observation matrix
pi = np.random.rand(N)
pi = np.apply_along_axis(lambda x : abs(x - (np.sum(x) - 1) / len(x)), 0, pi) # Initial state distrubition

#Needed for Re-estimation of matrices in 10a
A_prime = np.zeros((N,N))
A_prime_i = np.zeros(N)
B_prime = np.zeros((N,M))
B_prime_i = np.zeros(N)
W = np.zeros((N,N)) # N X N matrix of 0's
V = np.zeros((N,M)) # N X M matrix of 0's

def calculateAlphaPass():
    scale_matrix = []   # Will hold scale factors for each observation
    # Initialize and create the alpha matrix.  Row zero is alpha 0 of i, row 1
    # is alpha 1 of i... etc up til alpha T of i
    alphaMatrix = []
    for i in range(T):
        alphaMatrix.append([])

    # Calculates alpha 0 for every state
    scale_matrix.append(0)
    for i in range(0,N):
        alphaMatrix[0].append(pi[i] * B[i][observation[0]])
        scale_matrix[0] += alphaMatrix[0][i]

    # Scale alpha matrix 0 (row 0 of alpha matrix)
    scale_matrix[0] = 1/scale_matrix[0]
    for i in range(0,N):
        alphaMatrix[0][i] = scale_matrix[0] * alphaMatrix[0][i]

    # Computer alpha t for every state
    for t in range(1, T):
        scale_matrix.append(0)
        for i in range(0, N):
            alphaMatrix[t].append(0)
            for j in range(0, N):
                alphaMatrix[t][i] = alphaMatrix[t][i] + (alphaMatrix[t-1][j] * A[j][i])
            alphaMatrix[t][i] = alphaMatrix[t][i] * B[i][observation[t]]
            scale_matrix[t] += alphaMatrix[t][i]

        # Scale the rest of the alpha matrix (row 1 -> row T-1)
        scale_matrix[t] = 1/scale_matrix[t]
        for i in range(N):
            alphaMatrix[t][i] = scale_matrix[t] * alphaMatrix[t][i]
    return alphaMatrix, scale_matrix

def calculateBetaPass(scale):
    # Let Beta T-1 (i) = 1, scaled by C T-1
    betaMatrix = []
    for i in range(T):
        betaMatrix.append([])   # Creates the lists within the list (2d array/matrix)
    for i in range(N):
        betaMatrix[T-1].append(scale[T-1])
    # Claculate beta pass (backwards for loop from T-2 to 0 (using -1 since its exclusive))
    for t in range(T-2, -1, -1):
        for i in range(0,N):
            betaMatrix[t].append(0)
            for j in range(0,N):
                betaMatrix[t][i] += A[i][j] * B[j][observation[t+1]] * betaMatrix[t+1][j]
            # Scale B[t][i] with same scale factor is alpha[t][i]
            betaMatrix[t][i] = scale[t] * betaMatrix[t][i]

    return betaMatrix

def calculateGammas(alphaT, betaT):
    gamma = [[0]*N for i in range(T)]
    di_gamma = [[[0]*N for i in range(N)] for j in range(T)]
    for t in range(0, T-1):
        for i in range(0, N):
            for j in range(0,N):
                di_gamma[t][i][j] = alphaT[t][i] * A[i][j] * B[j][observation[t+1]] * betaT[t+1][j]
                gamma[t][i] += di_gamma[t][i][j]

    for i in range(0, N):
        gamma[T-1][i] = alphaT[T-1][i]

    return gamma, di_gamma

def re_estimate_matrices(alphaT, betaT, gammaT, di_gammaT, scale):
    print("Gamma in method: ", gammaT)
    print("Di gamma in method: ", di_gammaT)
    Re-estimate pi matrix
    for i in range(0, N):
        pi[i] = gammaT[0][i]

    # Estimate W which is used in the re-estimation of A
    for i in range(0, N):
        for j in range(0, N):
            cPrime = math.log10(scale[T - 1])
            sumDigam = 0
            sumGam = 0
            for t in range(T - 1):
                cPrime += math.log10(scale[t])
                sumDigam += di_gammaT[t][i][j]
                sumGam += gammaT[t][i]
            A_prime[i][j] = sumDigam
            A_prime_i[i] = sumGam
            W[i][j] += (alphaConstant / cPrime) * (A_prime[i][j] - A_prime_i[i] * A[i][j])

    # Estimate V which will be used in re-estimation of B
    for i in range(N):
        for j in range(M):
            jT = 0
            sumGam2 = 0
            for t in range(T):
                if (observation[t] == j):
                    jT += gammaT[t][i]
                sumGam2 += gammaT[t][i]
            B_prime[i][j] = jT
            B_prime_i[i] = sumGam2
            V[i][j] = V[i][j] + (alphaConstant / cPrime) * (B_prime[i][j] - B_prime_i[i] * B[i][j])

    # Re-estimate A
    for i in range(0, N):
        for j in range(0, N):
            numer = 0
            denom = 0
            for t in range(0, T-2):
                numer += di_gammaT[i][j]
                denom += gammaT[i]
            A[i][j] = numer/denom

    # Re-estimate B
    for i in range(0, N):
        for j in range(M):
            sumW = 0
            for t in range(0, M):
                sumW += np.exp(temperature * V[i][t])
            B[i][j] = np.exp(temperature * V[i][j]) / sumW
    return pi, A, B

def computeLogProbablity(scale):
    logProb = 0
    for i in range(T):
        logProb += math.log10(scale[i])
    logProb = -logProb

    return logProb

#print out B, transition matrix
print(np.transpose(B))